```markdown
# Azure Open AI: lidando com a capacidade e limites de cota com Bicep

### DEV Community

**Siga novos Subforems para melhorar seu feed**  

#### DEV Community
Um espaço para discutir e acompanhar o desenvolvimento de software e gerenciar sua carreira na área.

#### Gamers Forem
Uma comunidade inclusiva para entusiastas de jogos.

#### Future
Notícias e discussões sobre ciência e tecnologia, como IA, VR, criptomoedas, computação quântica e muito mais.

#### Music Forem
De composição e shows a equipamento, opiniões quentes sobre música e tudo mais.

#### Vibe Coding Forem
Discutindo desenvolvimento de software com IA e mostrando o que estamos criando.

#### Popcorn Movies and TV
Entusiasmo, críticas de filmes e TV e tudo o que está entre eles.

#### Open Forem
Um espaço de discussão geral para a comunidade Forem. Se não tiver um lar em outro lugar, pertence aqui.

#### DUMB DEV Community
Memes e postagens engraçadas sobre desenvolvimento de software.

#### Design Community
Design de web, design gráfico e tudo que está entre eles.

#### Golf Forem
Uma comunidade de golfistas e entusiastas do golfe.

#### Security Forem
Seu hub central para tudo relacionado à segurança. Desde hacking ético e CTFs até GRC e desenvolvimento de carreira, para iniciantes e profissionais.

#### Scale Forem
Para engenheiros que constroem software em larga escala. Discutimos arquitetura, cloud-native e SRE — as lições difíceis que você não pode apenas pesquisar no Google.

#### Forem Core
Discussão sobre o projeto de software de código aberto Core Forem — recursos, bugs, desempenho, hospedagem própria.

#### Crypto Forem
Uma comunidade colaborativa para tudo sobre Crypto — de Bitcoin ao desenvolvimento de protocolos e DeFi a NFTs e análise de mercado.

#### Parenting
Um lugar para pais compartilharem as alegrias, desafios e sabedoria que vêm de criar filhos. Estamos aqui para eles e uns para os outros.

#### Maker Forem
Uma comunidade para criadores, hobbyistas e profissionais discutirem Arduino, Raspberry Pi, impressão 3D e muito mais.

---

## Azure Open AI: Lidando com Capacidade e Limites de Cota com Bicep

Estamos atualmente no período de "corrida do ouro" da IA. O mundo não consegue o suficiente. Uma consequência disso é que o racionamento está em vigor. É como o fim da Segunda Guerra Mundial, mas com GPUs. Isso é algo bom, porque significa que não podemos simplesmente gerar tantos recursos quanto quisermos. É algo ruim pela mesma razão.

Se você está utilizando os recursos de IA da Azure Open AI para suas necessidades, você deve estar ciente de que existem limites conhecidos como "cotas". Se você deseja controlar quantos recursos está utilizando, precisará ser capaz de controlar a capacidade de seus deployments. Isso é possível com Bicep.

Este post surgiu a partir de uma questão no GitHub sobre o tema, onde as pessoas estavam entrando em contato com a mensagem de que a capacidade deveria ser nula para deployment padrão, enquanto tentavam implantar. Na época em que a questão foi levantada, havia muito pouca documentação sobre como lidar com isso. Desde então, as coisas melhoraram, mas achei que seria útil ter um post sobre o assunto.

### Visualizando limites de capacidade e cota no Azure Open AI Studio

Se você olhar para o Azure Open AI Studio, notará uma seção "Quotas". Você verá que temos duas implantações de GPT-35-Turbo em nossa assinatura. Ambas contribuem para um limite total de 360K TPM. Se tentarmos implantar recursos e tivermos um total de capacidade geral que exceda isso, nossa implantação falhará. Dado isso, precisamos ser capazes de controlar a capacidade de nossas implantações. Isso é possível com Bicep.

### Controlando capacidade e limites de cota com Bicep

Considere o seguinte arquivo `account-deployments.bicep`:

```bicep
@description('Nome do recurso de Serviços Cognitivos')
param cognitiveServicesName string
@description('Nome do recurso de implantação.')
param deploymentName string
@description('Formato do modelo de implantação.')
param format string
@description('Nome do modelo de implantação.')
param name string
@description('Versão do modelo de implantação.')
param version string = '1'
@description('O nome da política RAI.')
param raiPolicyName string = 'Default'
@allowed([
  'NoAutoUpgrade'
  'OnceCurrentVersionExpired'
  'OnceNewDefaultVersionAvailable'
])
@description('Opção de upgrade da versão do modelo de implantação.')
param versionUpgradeOption string = 'OnceNewDefaultVersionAvailable'
@description('''SKU de implantações''')
param sku object

resource cog 'Microsoft.CognitiveServices/accounts@2023-05-01' existing = {
  name: cognitiveServicesName
}

resource deployment 'Microsoft.CognitiveServices/accounts/deployments@2023-05-01' = {
  name: deploymentName
  parent: cog
  sku: sku
  properties: {
    model: {
      format: format
      name: name
      version: version
    }
    raiPolicyName: raiPolicyName
    versionUpgradeOption: versionUpgradeOption
  }
}

output deploymentName string = deployment.name
output deploymentResourceId string = deployment.id
```
  
Podemos usar isso para implantar.... implantações (a nomenclatura aqui é definitivamente confusa) para o Azure desta forma:

```bicep
var cognitiveServicesDeployments = [
  {
    name: 'OpenAi-gpt-35-turbo'
    shortName: 'gpt35t'
    model: {
      format: 'OpenAI'
      name: 'gpt-35-turbo'
      version: '0301'
    }
    sku: {
      name: 'Standard'
      capacity: repositoryBranch == 'refs/heads/main' ? 100 : 10
    }
  }
]

@batchSize(1)
module openAiAccountsDeployments35Turbo 'account-deployments.bicep' = [
  for deployment in cognitiveServicesDeployments: {
    name: '${deployment.shortName}-cog-accounts-deployments'
    params: {
      cognitiveServicesName: openAi.outputs.cognitiveServicesName
      deploymentName: deployment.name
      format: deployment.model.format
      name: deployment.model.name
      version: deployment.model.version
      sku: deployment.sku
    }
  }
]
```

Estamos atualmente apenas implantando uma única implantação de conta em nosso array, mas fazemos isso dessa forma, pois não é incomum implantar várias implantações juntas. Observe a parte `sku` acima. Aqui provisionamos uma capacidade maior para nossas implantações de branch de feature do que para as implantações de branch principal.

Isso demonstra nosso próprio uso, onde implantamos uma capacidade menor para nossas branches de feature, de modo que possamos testar coisas, mas depois implantamos uma capacidade maior para nossas implantações de branches principais. Significativamente, estamos controlando a capacidade de nossas implantações. A maneira como você optar por decidir a capacidade de suas implantações é sua, mas o acima demonstra como você pode fazer isso com Bicep e permanecer dentro de seus limites de cota.
```